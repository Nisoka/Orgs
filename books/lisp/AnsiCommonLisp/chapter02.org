1 Lisp 的交互式前端 叫做顶层 toplevel.
2 Lisp 中的程序 都是表达式, 可以被求值 -- 所以LISP也可以叫做求值循环.
3 操作符在表达式最前端，几乎所有操作符 都是函数， 
  特殊操作符  quote -- ' 表示对其参数认为是列表, 什么都不做 返回.
4 符号不能对其自身求值, 所以要想引用符号， 不能直接写 symbol ， 必须加上'symbol
  表示不允许其求值, 原样输出.
5 list 列表 列表的元素可以任意类型, 但是引用列表必须使用' 不然会被认为是个表达式被求值.
  如果一个列表被引用了，则求值规则对列表自身来求值；
  如果没有被引用，则列表被视为是代码，依求值规则对列表求值后，返回它的值.
6 t 表示真, nil 表示逻辑假. 
  函数返回 逻辑真 假 时，称该函数为 谓词函数 predicate 通常以p结束.（listp 1） > nil
  nil 也表示空列表, 所以 对于 (null nil) >t
  nil 表示假                  (not nil) > t
7 特殊操作符 if  + test表达式 + then 表达式 + else表达式.

8 特殊操作符 and or  实际上是 宏.
  高级点的人写 and or 会感觉类似 if
  and 就是 if true then
  or  就是 if false then

9 函数 (defun funcname (paramters)  ()()()()()... )

10 变量就是 被定义了类型对象的符号， 而符号本身也是对象，所以使用符号，
  必须使用' 进行引用, 不然会当称变量 被求值.
  
11 lisp 不对程序、过程、函数做区别
  你可以随意在toplevel 调用任何函数, 程序就是一个函数集合体, 你可以一块一块的调用程序
  一块一块的运行调试程序

12 递归函数
  理解递归 就是过程, 过程是可以递归自己扩散循环调用的, 直到到达一个终止节点.

13 let 局部变量
  let 是最常用操作符, 也不是函数，目的是引入局部变量

14 defparameter *全局变量* 
  全局变量任何地方都可以访问
  
15 defconstant  全局常量
  全局常量 在整个环境中不允许被设置.
  boundp 检查是否是个全局量(全局常量 或 全局变量)

16 赋值 setq 给全局变量 局部变量赋值
  setq 会检查变量符号 是否是个局部变量名字, 如果不是 则会创建为全局变量.
  所以setq 会隐式创建全局变量, 但是最好是使用defparamter

17 函数式编程
  函数式变成是 利用返回值工作的程序，而不是C++允许使用指针 而对对象进行修改.
  只用返回值进行编程 会感觉很不自由, 但是通过lisp的toplevel 你可以实时运行、编程、再运行.
  函数式编程.

18 迭代
  do ((i start (+ i 1)))
     ((> i end)
     'done)
19 特殊操作符 progn 
  接收任意数量表达式, 依次执行.
  对于某些宏 do if and 等宏 他们会有固定的格式, then表达式只有一个 这时候可以用
  progn 将多个表达式 认为是一个表达式.

20 函数也是对象
  特殊操作符 function 
  function 接一个函数名, 会返回函数对象,
  函数对象 被打印出来 一般是#<Compiled-Function + 17BA4E>的形式.
  
  quote == '
  function == #'
  > #'+
   #<Compiled-Function + 17BA4E>
21 函数 apply + func-obj(#<Compiled-Function + 17BA4E>) + list( 作为func的参数列表， 需要使用' 引用)
   函数 funcall + func-obj(#<Compiled-Function + 17BA4E>) + 多个参数(实际上就是不加括号的 func的参数列表)

22 函数对象
   函数对象 在内部是用list表示的, 直接通过((x) (+ x 100)) 就定义了
   一个函数对象, 但是这样书写不够明确 所以有如下: 23 24

23 *特殊符号 不是一个操作符* ---lambda 
   由于函数在内部用列表表示, 通过特殊符号来进行标示
   (lambda (x) (+ x 100)) 就定义了一个函数对象.

24 defun 宏 创建一个函数, 并分配符号作为函数名字, 可以通过符号引用函数.

25 lambda 表达式前面贴上 #' ，我们得到对应的函数对象。

26 Common Lisp 的类型 不同于C等语言, 变量不需要类型, 变量就是内存地址, 可以随意
   使用任意类型数据，只有数据才是有类型的, 这才是更复合实际的.
   内置类型，组成了一个类别的层级。对象总是不止属于一个类型。举例来说，数字 27 的类型，依普遍性的增加排序，依序是 fixnum 、 integer 、 rational 、 real 、 number 、 atom 和 t 类型。（数值类型将在第 9 章讨论。）类型 t 是所有类型的基类（supertype）。所以每个对象都属于 t 类型


  
 



