(let ((x 10))
  (defun foo ()
    (declare (special x))
    x))

;; 6.1 global function
;; 6.2 local function
;; 6.3 parameter lists
;; 6.4 utilities
;; 实用工具, 就是语言本身
;; Lisp 语言大部分是由lisp函数构成的. 这样你不需要改变你的想法来适应语言, 而是可以通过改变语言来更好的实现想法.
;; 所以lisp语言 可以由下而上, 在实现程序过程中, 创造一个更好的lisp方言. 这样最后的程序实际上还可继续编程, 已经成为了一个语言.

;; 6.5 closure
;; 闭包
;; 词法变量（lexical variables）只在被定义的上下文内有效。伴随这个限制而来的是，只要那个上下文还有在使用，它们就保证会是有效的。
;; 如果函数在词法变量的作用域里被定义时，函数仍可引用到那个变量，即便函数被作为一个值返回了，返回至词法变量被创建的上下文之外
;; 当函数引用到外部定义的变量时，这外部定义的变量称为自由变量（free variable）。
;; 函数引用到自由的词法变量时，称之为闭包（closure）。 [2] 只要函数还存在，变量就必须一起存在。
;; 闭包结合了函数与环境（environment）；
;; 无论何时，当一个函数引用到周围词法环境的某个东西时，闭包就被隐式地创建出来了。

;; 6.6 function builders
;; 6.7 dynamic scope
;; 局部与全局变量的差别。
;; 实际的差别是词法作用域（lexical scope）的词法变量（lexical variable），与动态作用域（dynamic scope）的特别变量（special variable）的区别。
;; 局部变量几乎总是是词法变量，而全局变量总是是特别变量

;; 在词法作用域下，
;; 一个符号引用到上下文中符号名字出现的地方。局部变量缺省有着词法作用域。所以如果我们在一个环境里定义一个函数(闭包环境)，其中有一个变量叫做 x
;; (let ((x 10))
;;   (defun foo ()
;;     x))
;; 则无论 foo 被调用时有存在其它的 x ，主体内的 x 都会引用到那个变量:
;; > (let ((x 20)) (foo))
;; 10

;; 而动态作用域，
;; 我们在函数被调用的环境中寻找变量。要使一个变量是动态作用域的，我们需要在任何它出现的上下文中声明它是 special 。如果我们这样定义 foo ：
;; (let ((x 10))
;;  (defun foo ()
;;    (declare (special x))
;;    x))
;; 则函数内的 x 就不再引用到函数定义里的那个词法变量，但会引用到函数被调用时，当下环境所存在的任何特别变量 x :
;; > (let ((x 20))
;;     (declare (special x))
;;     (foo))
;; 20

;; 新的变量被创建出来之后， 一个 declare 调用可以在代码的任何地方出现。 special 声明是独一无二的，因为它可以改变程序的行为
;; 通过在顶层调用 setf 来配置全局变量，是隐式地将变量声明为特殊变量:

;; 动态作用域什么时候会派上用场呢？通常用来暂时给某个全局变量赋新值。
;; 给全局变量使用let 进行赋值,则形成了动态作用域的特殊变量 工作在词法作用域中, 这样在当前词法环境let完成时,特殊变量又回到了全局作用域,
;; 这叫动态作用域.



;; 6.8 compile
;; 6.9 using recursion
;; 比起多数别的语言，递归在 Lisp 中扮演了一个重要的角色。这主要有三个原因：

;; 函数式程序设计。递归演算法有副作用的可能性较低。
;; 递归数据结构。 Lisp 隐式地使用了指标，使得递归地定义数据结构变简单了。最常见的是用在列表：一个列表的递归定义，列表为空表，或是一个 cons ，其中 cdr 也是个列表。
;; 优雅性。Lisp 程序员非常关心它们的程序是否美丽，而递归演算法通常比迭代演算法来得优雅。


;; 同样的如果你想写一个递归函数。如果你可以描述问题是怎么递归解决的，通常很容易将解法转成代码。要使用递归来解决一个问题，你需要做两件事：

;; 你必须要示范如何解决问题的一般情况，通过将问题切分成有限小并更小的子问题。
;; 你必须要示范如何通过 ── 有限的步骤，来解决最小的问题 ── 基本用例。

